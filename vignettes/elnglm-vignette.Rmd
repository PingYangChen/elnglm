---
title: "Generalized Linear Model with Elastic Net Penalty"
author: "Ping-Yang Chen"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


Let $(\mathbf{y}, \mathbf{X})$ be the data of $n$ observations, where $\mathbf{y}\in\mathbb{R}^n$ is the vector of the response variable and $\mathbf{X}\in\mathbb{R}^{n\times p}$ is the matrix of $p$ covariates. 


```{r, eval=TRUE}
library(elnglm)
library(glmnet)
```
## Supportive Data Type of **elnglm**

### Continuous Response

```{r, eval=FALSE}
family <- "gaussian"
```

Use \code{glmDataGen} to generate data with continuous response.

```{r, eval=TRUE}
library(elnglm)

set.seed(1)
trueb0 <- 1
trueact <- c(1, 1, 1, 0, 0, 0, 0, 0, 0, 0)
trueb <- runif(10, -1, 1)*10
trueb[which(trueact == 0)] <- 0 
#
df <- glmDataGen(500, 10, family = "gaussian", trueb0, trueb, s = 0.5, seed = 1)

```

Use \code{glmDataGen} to generate data with continuous 

```{r, eval=TRUE}
resSelf <- glmPenaltyCV(y = df$y, x = df$x, family = "gaussian", 
                        lambdaLength = 100, maxit = 1e5, tol = 1e-7,
                        alpha = 0.5, minLambdaRatio = 1e-3, nfolds = 5, ver = "arma")


resSelf$b0[resSelf$lambdaBestId]
resSelf$b[,resSelf$lambdaBestId]
resSelf$lambda[resSelf$lambdaBestId]
resSelf$cvscore

resSelf$b0[1]
resSelf$b[,1]
resSelf$lambda

library(glmnet)
resPkg <- cv.glmnet(y = df$y, x = df$x, family = family, 
                    lambda = resSelf$lambda, alpha = 0.5, maxit = 1e5, thresh = 1e-7,
                    type.measure = "mse", nfolds = 5, foldid = resSelf$foldid)

resPkg$glmnet.fit$a0[which.min(resPkg$cvm)]
resPkg$glmnet.fit$beta[,which.min(resPkg$cvm)]
resPkg$lambda[which.min(resPkg$cvm)]
resPkg$cvm

resPkg$glmnet.fit$a0[1]
resPkg$glmnet.fit$beta[,1]
resPkg$lambda

```


### Binary Response

```{r, eval=TRUE}
set.seed(1)
trueb0 <- 1
trueact <- c(1, 1, 1, 0, 0, 0, 0, 0, 0, 0)
trueb <- runif(10, -1, 1)*10
trueb[which(trueact == 0)] <- 0 
#
dfb <- glmDataGen(500, 10, family = "binomial", trueb0, trueb, s = 0.5, seed = 1)

```


```{r, eval=TRUE}
resSelf_b <- glmPenaltyCV(y = dfb$y, x = dfb$x, family = "binomial", 
                          lambdaLength = 100, maxit = 1e5, tol = 1e-7,
                          alpha = 0.5, minLambdaRatio = 1e-3, nfolds = 5, ver = "arma")


resSelf_b$b0[resSelf_b$lambdaBestId]
resSelf_b$b[,resSelf_b$lambdaBestId]
resSelf_b$lambda[resSelf_b$lambdaBestId]
resSelf_b$cvscore

resSelf_b$b0[1]
resSelf_b$b[,1]
resSelf_b$lambda

library(glmnet)
resPkg_b <- cv.glmnet(y = dfb$y, x = dfb$x, family = "binomial", 
                      lambda = resSelf_b$lambda, alpha = 0.5, maxit = 1e5, thresh = 1e-7,
                    type.measure = "deviance", nfolds = 5, foldid = resSelf_b$foldid)

resPkg_b$glmnet.fit$a0[which.min(resPkg_b$cvm)]
resPkg_b$glmnet.fit$beta[,which.min(resPkg_b$cvm)]
resPkg_b$lambda[which.min(resPkg_b$cvm)]
resPkg_b$cvm

resPkg_b$glmnet.fit$a0[1]
resPkg_b$glmnet.fit$beta[,1]
resPkg_b$lambda

```




### Multinomial Response

```{r, eval=TRUE}
set.seed(1)
trueb0 <- c(1, 1, 1)
trueact <- cbind(
  c(1, 1, 1, 0, 0, 0, 0, 0, 0, 0),
  c(0, 0, 0, 1, 1, 1, 1, 0, 0, 0),
  c(0, 0, 0, 0, 0, 1, 1, 1, 1, 0)
)
trueb <- matrix(runif(10*3, -1, 1)*10, 10, 3)
for (m in 1:3) { trueb[which(trueact[,m] == 0),m] <- 0 }
#
dfm <- glmDataGen(500, 10, family = "multinomial", trueb0, trueb, s = 0.5, seed = 1)

```


```{r, eval=TRUE}
resSelf_m <- glmPenaltyCV(y = dfm$y, x = dfm$x, family = "multinomial", 
                          lambdaLength = 100, maxit = 1e5, tol = 1e-7,
                          alpha = 0.5, minLambdaRatio = 1e-3, nfolds = 5, ver = "arma")


resSelf_m$b0[,resSelf_m$lambdaBestId]
resSelf_m$b[,,resSelf_m$lambdaBestId]
resSelf_m$lambda[resSelf_m$lambdaBestId]
resSelf_m$cvscore

resSelf_m$b0[1]
resSelf_m$b[,1]
resSelf_m$lambda

library(glmnet)
resPkg_m <- cv.glmnet(y = dfm$y, x = dfm$x, family = "multinomial", 
                      lambda = resSelf_b$lambda, alpha = 0.5, maxit = 1e5, thresh = 1e-7,
                    type.measure = "class", nfolds = 5, foldid = resSelf_m$foldid)

resPkg_m$glmnet.fit$a0[,which.min(resPkg_m$cvm)]
resPkg_m$glmnet.fit$beta[[1]][,which.min(resPkg_m$cvm)]
resPkg_m$glmnet.fit$beta[[2]][,which.min(resPkg_m$cvm)]
resPkg_m$glmnet.fit$beta[[3]][,which.min(resPkg_m$cvm)]
resPkg_m$lambda[which.min(resPkg_m$cvm)]
resPkg_m$cvm

resPkg_m$glmnet.fit$a0[1]
resPkg_m$glmnet.fit$beta[,1]
resPkg_m$lambda

```


## Performace Test


```{r, eval=TRUE}
library(elnglm)
library(glmnet)

set.seed(1)
trueb0 <- 1
trueact <- c(1, 1, 1, 0, 0, 0, 0, 0, 0, 0)
trueb <- runif(10, -1, 1)*10
trueb[which(trueact == 0)] <- 0 

family <- "gaussian"
df <- glmDataGen(500, 10, family, trueb0, trueb, s = 0.5, NULL)

cpu1 <- system.time({
  resSelf <- glmPenaltyCV(y = df$y, x = df$x, family, 
                          lambdaLength = 100, maxit = 1e5, tol = 1e-7,
                          alpha = 0.5, minLambdaRatio = 1e-3, nfold = 5, ver = "arma")
})

resSelf$b0
resSelf$b[,resSelf$lambdaBestId]
resSelf$lambda[resSelf$lambdaBestId]

cpu2 <- system.time({
  resPkg <- cv.glmnet(y = df$y, x = df$x, family = family, 
                      lambda = resSelf$lambda, alpha = 0.5, maxit = 1e5, thresh = 1e-7,
                      type.measure = "mse", nfolds = 5)
})



resPkg$glmnet.fit$beta[,which.min(resPkg$cvm)]



```


